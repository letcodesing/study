# 리스트 [] 요소 변경 삭제 가능-mutable
# 튜플 () 요소 변경 삭제 안됨-immutable
# 그러나 새로운 튜플을 정의하는 방식으로 업데이트하는 것은 가능하다
a=(1,2,3)
b=(3,5,6)
print('a의 원소들', a)
a=b+a
print('업데이트된 a', a)

# 딕셔너리{} 인덱스 순서가 없고 키로 접근한다 고로 데이터는 키와 데이터 쌍으로 입력하게 된다
# 키값의 타입은 상관없으나 같은 딕셔너리 내 중복은 불가능하다


t=dict()
print('클래스', type(t))

t={'바':1, '3':6, '6.3':10}
print('딕셔너리 t 정의', t)
t={'바':1, '3':6, '6.3':10, '바':52}
print('중복된 키값을 입력할 경우 마지막에 입력한 키의 밸류값으로 덮어씌어짐', t)

#t={'바':1, '3':6, '6.3':가} 밸류값에는 숫자만 가능하다?


print('바 키의 밸류값', t['바'])
# 없는 키값을 찾으면 에러 t['아']

#get을 쓰면 해당키가 없어도 에러가 나지 않고 none이 출력된다
print('get을 쓰면 키값이 없어도 에러가 나지 않는다', t.get('아'))

#모든 키값 출력
print('모든 키값 출력', t.keys())

#출력 키값을 리스트로 변환하기 위해 list사용
print('키값을 리스트로 변환', list(t.keys()))

#모든 value 조회
print('모든 밸류 조회', t.values())

#모든 키와 value 조회
print('모든 키와 밸류 조회', t.items())

#키값 조회

print('바' in t)
print('바' not in t)

#키에 해당하는 value 변경
t['바']=253
print('바의 밸류값 변경', t)

#키, 밸류 추가
t[0]=2

print('키와 밸류값 추가', t)

#한꺼번에 변경하고 싶다면 집합을 선언하고 해당키와 밸류를 넣어 업데이트한다

ftuit={'사과': 2000, '바다':3000, '육지':3000}
t.update(ftuit)
print('여러개의 키와 밸류값 추가', t)

#삭제
del t['바다']
print('바다 키와 밸류값 삭제', t)

#삭제되는 키의 value 조회
print('사과 키를 삭제하고 해당밸류 반환', t.pop('사과'), t)


#전부삭제
t.clear()
print('전체삭제', t)